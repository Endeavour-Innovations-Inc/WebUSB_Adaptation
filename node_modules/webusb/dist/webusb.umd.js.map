{"version":3,"file":"webusb.umd.js","sources":["../node_modules/rollup-plugin-node-builtins/src/es6/events.js","../src/dispatcher.ts","../src/configuration.ts","../src/interface.ts","../src/alternate.ts","../src/endpoint.ts","../src/device.ts","../src/adapter.ts","../src/events.ts","../src/usb.ts","../src/index.ts"],"sourcesContent":["'use strict';\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nexport default EventEmitter;\nexport {EventEmitter};\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2019 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventEmitter } from \"events\";\n\n// tslint:disable:ban-types\n\n/**\n * @hidden\n */\nexport interface EventListeners<T> {\n    newListener: keyof T;\n    removeListener: keyof T;\n}\n\n/**\n * @hidden\n */\nexport interface TypedDispatcher<T> {\n    addEventListener<K extends keyof T>(type: K, listener: (this: this, event: T[K]) => void): void;\n    addEventListener<E extends keyof EventListeners<T>>(type: E, listener: (this: this, event: EventListeners<T>[E]) => void): void;\n    removeEventListener<K extends keyof T>(type: K, callback: (this: this, event: T[K]) => void): void;\n    removeEventListener<E extends keyof EventListeners<T>>(type: E, callback: (this: this, event: EventListeners<T>[E]) => void): void;\n    dispatchEvent<K extends keyof T>(event: T[K]): boolean;\n    addListener<K extends keyof T>(event: K, listener: (data: T[K]) => void): this;\n    addListener<E extends keyof EventListeners<T>>(event: E, listener: (data: EventListeners<T>[E]) => void): this;\n    on<K extends keyof T>(event: K, listener: (data: T[K]) => void): this;\n    on<E extends keyof EventListeners<T>>(event: E, listener: (data: EventListeners<T>[E]) => void): this;\n    once<K extends keyof T>(event: K, listener: (data: T[K]) => void): this;\n    once<E extends keyof EventListeners<T>>(event: E, listener: (data: EventListeners<T>[E]) => void): this;\n    prependListener<K extends keyof T>(event: K, listener: (data: T[K]) => void): this;\n    prependOnceListener<K extends keyof T>(event: K, listener: (data: T[K]) => void): this;\n    removeListener<K extends keyof T>(event: K, listener: (data: T[K]) => void): this;\n    removeListener<E extends keyof EventListeners<T>>(event: E, listener: (data: EventListeners<T>[E]) => void): this;\n    removeAllListeners<K extends keyof T>(event?: K): this;\n    removeAllListeners<E extends keyof EventListeners<T>>(event?: E): this;\n    listeners<K extends keyof T>(event: K): Array<Function>;\n    listeners<E extends keyof EventListeners<T>>(event: EventListeners<T>[E]): Array<Function>;\n    emit<K extends keyof T>(event: K, data: T[K]): boolean;\n    eventNames<K extends keyof T, E extends keyof EventListeners<T>>(): Array<K | E>;\n    listenerCount<K extends keyof T>(type: K): number;\n    listenerCount<E extends keyof EventListeners<T>>(type: EventListeners<T>[E]): number;\n    setMaxListeners(n: number): this;\n    getMaxListeners(): number;\n}\n\n/**\n * @hidden\n */\nexport class EventDispatcher extends EventEmitter implements EventTarget {\n\n    private isEventListenerObject = (listener: EventListenerOrEventListenerObject): listener is EventListenerObject => (listener as EventListenerObject).handleEvent !== undefined;\n\n    public addEventListener(type: string, listener: EventListenerOrEventListenerObject | null) {\n        if (listener) {\n            const handler = this.isEventListenerObject(listener) ? listener.handleEvent : listener;\n            super.addListener(type, handler);\n        }\n    }\n\n    public removeEventListener(type: string, callback: EventListenerOrEventListenerObject | null) {\n        if (callback) {\n            const handler = this.isEventListenerObject(callback) ? callback.handleEvent : callback;\n            super.removeListener(type, handler);\n        }\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return super.emit(event.type, event);\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { USBInterface } from \"./interface\";\nimport { W3CUSBConfiguration } from \"./interfaces\";\n\n/**\n * USB Configuration\n */\nexport class USBConfiguration implements W3CUSBConfiguration {\n\n    /**\n     * The value of this configuration\n     */\n    public readonly configurationValue: number = null;\n\n    /**\n     * The name of this configuration\n     */\n    public readonly configurationName?: string = null;\n\n    /**\n     * The array of interfaces on this configuration\n     */\n    public readonly interfaces: Array<USBInterface> = [];\n\n    /**\n     * @hidden\n     */\n    constructor(init?: Partial<USBConfiguration>) {\n        this.configurationValue = init.configurationValue;\n        this.configurationName = init.configurationName;\n        this.interfaces = init.interfaces;\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { adapter } from \"./adapter\";\nimport { W3CUSBInterface } from \"./interfaces\";\nimport { USBAlternateInterface } from \"./alternate\";\n\n/**\n * USB Interface\n */\nexport class USBInterface implements W3CUSBInterface {\n\n    /**\n     * Number of this interface\n     */\n    public readonly interfaceNumber: number = null;\n\n    /**\n     * Array of alternate interfaces\n     */\n    public readonly alternates: Array<USBAlternateInterface> = [];\n\n    private _claimed: boolean = false;\n    /**\n     * Whether this interface is claimed\n     */\n    public get claimed(): boolean {\n        return this._claimed;\n    }\n\n    private _currentAlternate: number = 0;\n    /**\n     * Return the current alternate interface\n     */\n    public get alternate(): USBAlternateInterface {\n        return this.alternates.find(alternate => alternate.alternateSetting === this._currentAlternate);\n    }\n\n    /**\n     * @hidden\n     */\n    public readonly _handle: string = null;\n\n    /**\n     * @hidden\n     */\n    constructor(init?: Partial<USBInterface>) {\n        this.interfaceNumber = init.interfaceNumber;\n        this.alternates = init.alternates;\n\n        this._handle = init._handle;\n    }\n\n    /**\n     * @hidden\n     */\n    public selectAlternateInterface(alternateSetting: number): Promise<void> {\n        return adapter.selectAlternateInterface(this._handle, this.interfaceNumber, alternateSetting)\n        .then(() => {\n            this._currentAlternate = alternateSetting;\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    public claimInterface(): Promise<void> {\n        return adapter.claimInterface(this._handle, this.interfaceNumber)\n        .then(() => {\n            this._claimed = true;\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    public releaseInterface(): Promise<void> {\n        return adapter.releaseInterface(this._handle, this.interfaceNumber)\n        .then(() => {\n            this._claimed = false;\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    public reset() {\n        this._currentAlternate = 0;\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { USBEndpoint } from \"./endpoint\";\nimport { W3CUSBAlternateInterface } from \"./interfaces\";\n\n/**\n * USB Alternate Interface\n */\nexport class USBAlternateInterface implements W3CUSBAlternateInterface {\n\n    /**\n     * The alternate setting for this interface\n     */\n    public readonly alternateSetting: number = null;\n\n    /**\n     * The class of this interface\n     */\n    public readonly interfaceClass: number = null;\n\n    /**\n     * The sub class of this interface\n     */\n    public readonly interfaceSubclass: number = null;\n\n    /**\n     * The protocol of this interface\n     */\n    public readonly interfaceProtocol: number = null;\n\n    /**\n     * The name of this interface\n     */\n    public readonly interfaceName?: string = null;\n\n    /**\n     * The array of endpoints on this interface\n     */\n    public readonly endpoints: Array<USBEndpoint> = [];\n\n    /**\n     * @hidden\n     */\n    constructor(init?: Partial<USBAlternateInterface>) {\n        this.alternateSetting = init.alternateSetting;\n        this.interfaceClass = init.interfaceClass;\n        this.interfaceSubclass = init.interfaceSubclass;\n        this.interfaceProtocol = init.interfaceProtocol;\n        this.interfaceName = init.interfaceName;\n        this.endpoints = init.endpoints;\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { W3CUSBEndpoint } from \"./interfaces\";\n\n/**\n * USB Endpoint\n */\nexport class USBEndpoint implements W3CUSBEndpoint {\n\n    /**\n     * The number of this endpoint\n     */\n    public readonly endpointNumber: number = null;\n\n    /**\n     * The direction of this endpoint\n     */\n    public readonly direction: USBDirection = null;\n\n    /**\n     * The type of this endpoint\n     */\n    public readonly type: USBEndpointType = null;\n\n    /**\n     * The packet size of this endpoint\n     */\n    public readonly packetSize: number = null;\n\n    /**\n     * @hidden\n     */\n    constructor(init?: Partial<USBEndpoint>) {\n        this.endpointNumber = init.endpointNumber;\n        this.direction = init.direction;\n        this.type = init.type;\n        this.packetSize = init.packetSize;\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { LIBUSB_ENDPOINT_IN } from \"usb\";\nimport { USBConfiguration } from \"./configuration\";\nimport { adapter } from \"./adapter\";\nimport { W3CUSBDevice } from \"./interfaces\";\n\n/**\n * @hidden\n */\ninterface EndpointResult {\n    endpoint: USBEndpoint;\n    iface: USBInterface;\n}\n\n/**\n * USB Device\n */\nexport class USBDevice implements W3CUSBDevice {\n\n    /**\n     * Major USB protocol version supported by the device\n     */\n    public readonly usbVersionMajor: number;\n\n    /**\n     * Minor USB protocol version supported by the device\n     */\n    public readonly usbVersionMinor: number;\n\n    /**\n     * Sub minor USB protocol version supported by the device\n     */\n    public readonly usbVersionSubminor: number;\n\n    /**\n     * Communication interface class of the device\n     */\n    public readonly deviceClass: number;\n\n    /**\n     * Communication interface sub class of the device\n     */\n    public readonly deviceSubclass: number;\n\n    /**\n     * Communication interface protocol of the device\n     */\n    public readonly deviceProtocol: number;\n\n    /**\n     * Vendor Identifier of the device\n     */\n    public readonly vendorId: number;\n\n    /**\n     * Product Identifier of the device\n     */\n    public readonly productId: number;\n\n    /**\n     * Major version of the device\n     */\n    public readonly deviceVersionMajor: number;\n\n    /**\n     * Minor version of the device\n     */\n    public readonly deviceVersionMinor: number;\n\n    /**\n     * Sub minor version of the device\n     */\n    public readonly deviceVersionSubminor: number;\n\n    /**\n     * Manufacturer name of the device\n     */\n    public readonly manufacturerName: string = null;\n\n    /**\n     * Product name of the device\n     */\n    public readonly productName: string = null;\n\n    /**\n     * Serial number of the device\n     */\n    public readonly serialNumber: string = null;\n\n    private _configurations: Array<USBConfiguration> = [];\n    /**\n     * List of configurations supported by the device\n     */\n    public get configurations(): Array<USBConfiguration> {\n        return this._configurations;\n    }\n\n    /**\n     * @hidden\n     */\n    public _currentConfiguration: number = null;\n    /**\n     * The currently selected configuration\n     */\n    public get configuration(): USBConfiguration {\n        return this.configurations.find(configuration => configuration.configurationValue === this._currentConfiguration);\n    }\n\n    /**\n     * @hidden\n     */\n    public get connected(): boolean {\n        return adapter.getConnected(this._handle);\n    }\n\n    /**\n     * A flag indicating whether the device is open\n     */\n    public get opened(): boolean {\n        return adapter.getOpened(this._handle);\n    }\n\n    /**\n     * URL advertised by the device (not part of Web USB specification)\n     */\n    public readonly url: string = null;\n\n    /**\n     * @hidden\n     */\n    public readonly _maxPacketSize: number = 0;\n\n    /**\n     * @hidden\n     */\n    public readonly _handle: string = null;\n\n    /**\n     * @hidden\n     */\n    constructor(init?: Partial<USBDevice>) {\n        this.usbVersionMajor = init.usbVersionMajor;\n        this.usbVersionMinor = init.usbVersionMinor;\n        this.usbVersionSubminor = init.usbVersionSubminor;\n        this.deviceClass = init.deviceClass;\n        this.deviceSubclass = init.deviceSubclass;\n        this.deviceProtocol = init.deviceProtocol;\n        this.vendorId = init.vendorId;\n        this.productId = init.productId;\n        this.deviceVersionMajor = init.deviceVersionMajor;\n        this.deviceVersionMinor = init.deviceVersionMinor;\n        this.deviceVersionSubminor = init.deviceVersionSubminor;\n\n        this.manufacturerName = init.manufacturerName;\n        this.productName = init.productName;\n        this.serialNumber = init.serialNumber;\n\n        this._configurations = init.configurations;\n\n        this.url = init.url;\n        this._maxPacketSize = init._maxPacketSize;\n        this._handle = init._handle;\n        this._currentConfiguration = init._currentConfiguration;\n    }\n\n    private getEndpoint(direction: USBDirection, endpointNumber: number): EndpointResult {\n        let endpoint = null;\n        let iface = null;\n\n        this.configuration.interfaces.some(usbInterface => {\n            endpoint = usbInterface.alternate.endpoints.find(usbEndpoint => {\n                return (usbEndpoint.endpointNumber === endpointNumber && usbEndpoint.direction === direction);\n            });\n\n            if (endpoint) iface = usbInterface;\n            return endpoint;\n        });\n\n        return {\n            endpoint: endpoint,\n            iface: iface\n        };\n    }\n\n    private setupInvalid(setup: USBControlTransferParameters): string {\n        if (setup.recipient === \"interface\") {\n            const interfaceNumber = setup.index & 0xff; // lower 8 bits\n            const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n            if (!iface) return \"interface not found\";\n            if (!iface.claimed) return \"invalid state\";\n\n        } else if (setup.recipient === \"endpoint\") {\n            const endpointNumber = setup.index & 0x0f; // lower 4 bits\n            const direction = setup.index & LIBUSB_ENDPOINT_IN ? \"in\" : \"out\";\n\n            const result = this.getEndpoint(direction, endpointNumber);\n            if (!result.endpoint) return \"endpoint not found\";\n            if (!result.iface.claimed) return \"invalid state\";\n        }\n    }\n\n    /**\n     * Opens the device\n     */\n    public open(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"open error: device not found\"));\n            if (this.opened) return resolve();\n\n            adapter.open(this._handle)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`open error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Closes the device\n     */\n    public close(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"close error: device not found\"));\n            if (!this.opened) return resolve();\n\n            const releaseInterfacePromises = this.configuration.interfaces.map(\n                iface => this.releaseInterface(iface.interfaceNumber));\n\n            Promise.all(releaseInterfacePromises)\n            .catch(_error => { /* Ignore */ })\n            .then(() => adapter.close(this._handle))\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`close error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Select a configuration for the device\n     * @param configurationValue The configuration value to select\n     * @returns Promise containing any error\n     */\n    public selectConfiguration(configurationValue: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n\n            // Don't change the configuration if it's already set correctly\n            if (configurationValue === this._currentConfiguration) return resolve();\n\n            if (!this.connected) return reject(new Error(\"selectConfiguration error: device not found\"));\n\n            const config =  this.configurations.find(configuration => configuration.configurationValue === configurationValue);\n            if (!config) return reject(new Error(\"selectConfiguration error: configuration not found\"));\n\n            if (!this.opened) return reject(new Error(\"selectConfiguration error: invalid state\"));\n\n            adapter.selectConfiguration(this._handle, configurationValue)\n            .then(() => {\n                this._currentConfiguration = configurationValue;\n                this.configuration.interfaces.forEach(iface => iface.reset());\n                resolve();\n            })\n            .catch(error => {\n                reject(new Error(`selectConfiguration error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Claim an interface on the device\n     * @param interfaceNumber The interface number to claim\n     * @returns Promise containing any error\n     */\n    public claimInterface(interfaceNumber: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"claimInterface error: device not found\"));\n\n            const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n            if (!iface) return reject(new Error(\"claimInterface error: interface not found\"));\n            if (!this.opened) return reject(new Error(\"claimInterface error: invalid state\"));\n            if (iface.claimed) return resolve();\n\n            iface.claimInterface()\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`claimInterface error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Release an interface on the device\n     * @param interfaceNumber The interface number to release\n     * @returns Promise containing any error\n     */\n    public releaseInterface(interfaceNumber: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"releaseInterface error: device not found\"));\n\n            const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n            if (!iface) return reject(new Error(\"releaseInterface error: interface not found\"));\n            if (!this.opened) return reject(new Error(\"releaseInterface error: invalid state\"));\n            if (!iface.claimed) return resolve();\n\n            iface.releaseInterface()\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`releaseInterface error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Select an alternate interface on the device\n     * @param interfaceNumber The interface number to change\n     * @param alternateSetting The alternate setting to use\n     * @returns Promise containing any error\n     */\n    public selectAlternateInterface(interfaceNumber: number, alternateSetting: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"selectAlternateInterface error: device not found\"));\n\n            const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n            if (!iface) return reject(new Error(\"selectAlternateInterface error: interface not found\"));\n\n            if (!this.opened || !iface.claimed) return reject(new Error(\"selectAlternateInterface error: invalid state\"));\n\n            iface.selectAlternateInterface(alternateSetting)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`selectAlternateInterface error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Undertake a control transfer in from the device\n     *\n     * @param setup The USB control transfer parameters\n     * @param length The amount of data to transfer\n     * @returns Promise containing a result\n     */\n    public controlTransferIn(setup: USBControlTransferParameters, length: number): Promise<USBInTransferResult> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"controlTransferIn error: device not found\"));\n            if (!this.opened) return reject(new Error(\"controlTransferIn error: invalid state\"));\n\n            const setupError = this.setupInvalid(setup);\n            if (setupError) return reject(new Error(`controlTransferIn error: ${setupError}`));\n\n            adapter.controlTransferIn(this._handle, setup, length)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`controlTransferIn error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Undertake a control transfer out to the device\n     *\n     * __Note:__ The bytesWritten always set to the length of the data\n     *\n     * @param setup The USB control transfer parameters\n     * @param data The data to transfer\n     * @returns Promise containing a result\n     */\n    public controlTransferOut(setup: USBControlTransferParameters, data?: BufferSource): Promise<USBOutTransferResult> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"controlTransferOut error: device not found\"));\n            if (!this.opened) return reject(new Error(\"controlTransferOut error: invalid state\"));\n\n            const setupError = this.setupInvalid(setup);\n            if (setupError) return reject(new Error(`controlTransferOut error: ${setupError}`));\n\n            adapter.controlTransferOut(this._handle, setup, data)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`controlTransferOut error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Clear a halt condition on an endpoint\n     *\n     * @param direction The direction of the endpoint to clear\n     * @param endpointNumber The endpoint number of the endpoint to clear\n     * @returns Promise containing any error\n     */\n    public clearHalt(direction: USBDirection, endpointNumber: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"clearHalt error: device not found\"));\n\n            const result = this.getEndpoint(direction, endpointNumber);\n            if (!result.endpoint) return reject(new Error(\"clearHalt error: endpoint not found\"));\n            if (!this.opened || !result.iface.claimed) return reject(new Error(\"clearHalt error: invalid state\"));\n\n            adapter.clearHalt(this._handle, direction, endpointNumber)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`clearHalt error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Undertake a transfer in from the device\n     *\n     * @param endpointNumber The number of the endpoint to transfer from\n     * @param length The amount of data to transfer\n     * @returns Promise containing a result\n     */\n    public transferIn(endpointNumber: number, length: number): Promise<USBInTransferResult> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"transferIn error: device not found\"));\n\n            const result = this.getEndpoint(\"in\", endpointNumber);\n            if (!result.endpoint) return reject(new Error(\"transferIn error: endpoint not found\"));\n            if (result.endpoint.type !== \"interrupt\" && result.endpoint.type !== \"bulk\") return reject(new Error(\"transferIn error: invalid access\"));\n            if (!this.opened || !result.iface.claimed) return reject(new Error(\"transferIn error: invalid state\"));\n\n            adapter.transferIn(this._handle, endpointNumber, length)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`transferIn error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Undertake a transfer out to the device\n     *\n     * __Note:__ The bytesWritten always set to the length of the data\n     *\n     * @param endpointNumber The number of the endpoint to transfer to\n     * @param data The data to transfer\n     * @returns Promise containing a result\n     */\n    public transferOut(endpointNumber: number, data: BufferSource): Promise<USBOutTransferResult> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"transferOut error: device not found\"));\n\n            const result = this.getEndpoint(\"out\", endpointNumber);\n            if (!result.endpoint) return reject(new Error(\"transferOut error: endpoint not found\"));\n            if (result.endpoint.type !== \"interrupt\" && result.endpoint.type !== \"bulk\") return reject(new Error(\"transferOut error: invalid access\"));\n            if (!this.opened || !result.iface.claimed) return reject(new Error(\"transferOut error: invalid state\"));\n\n            adapter.transferOut(this._handle, endpointNumber, data)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`transferOut error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * @hidden\n     * Undertake an isochronous transfer in from the device\n     * @param endpointNumber The number of the endpoint to transfer from\n     * @param packetLengths An array of packet lengths outlining the amount to transfer\n     * @returns Promise containing a result\n     */\n    public isochronousTransferIn(endpointNumber: number, packetLengths: Array<number>): Promise<USBIsochronousInTransferResult> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"isochronousTransferIn error: device not found\"));\n\n            const result = this.getEndpoint(\"in\", endpointNumber);\n            if (!result.endpoint) return reject(new Error(\"isochronousTransferIn error: endpoint not found\"));\n            if (result.endpoint.type !== \"isochronous\") return reject(new Error(\"isochronousTransferIn error: invalid access\"));\n            if (!this.opened || !result.iface.claimed) return reject(new Error(\"isochronousTransferIn error: invalid state\"));\n\n            adapter.isochronousTransferIn(this._handle, endpointNumber, packetLengths)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`isochronousTransferIn error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * @hidden\n     * Undertake an isochronous transfer out to the device\n     * @param endpointNumber The number of the endpoint to transfer to\n     * @param data The data to transfer\n     * @param packetLengths An array of packet lengths outlining the amount to transfer\n     * @returns Promise containing a result\n     */\n    public isochronousTransferOut(endpointNumber: number, data: BufferSource, packetLengths: Array<number>): Promise<USBIsochronousOutTransferResult> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"isochronousTransferOut error: device not found\"));\n\n            const result = this.getEndpoint(\"out\", endpointNumber);\n            if (!result.endpoint) return reject(new Error(\"isochronousTransferOut error: endpoint not found\"));\n            if (result.endpoint.type !== \"isochronous\") return reject(new Error(\"isochronousTransferOut error: invalid access\"));\n            if (!this.opened || !result.iface.claimed) return reject(new Error(\"isochronousTransferOut error: invalid state\"));\n\n            adapter.isochronousTransferOut(this._handle, endpointNumber, data, packetLengths)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`isochronousTransferOut error: ${error}`));\n            });\n        });\n    }\n\n    /**\n     * Soft reset the device\n     * @returns Promise containing any error\n     */\n    public reset(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.connected) return reject(new Error(\"reset error: device not found\"));\n            if (!this.opened) return reject(new Error(\"reset error: invalid state\"));\n\n            adapter.reset(this._handle)\n            .then(resolve)\n            .catch(error => {\n                reject(new Error(`reset error: ${error}`));\n            });\n        });\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventEmitter } from \"events\";\nimport {\n    getDeviceList,\n    Device,\n    Endpoint,\n    InEndpoint,\n    OutEndpoint,\n    ConfigDescriptor,\n    InterfaceDescriptor,\n    on,\n    removeListener,\n    LIBUSB_ENDPOINT_IN,\n    LIBUSB_ENDPOINT_OUT,\n    LIBUSB_TRANSFER_OVERFLOW,\n    LIBUSB_TRANSFER_STALL,\n    LIBUSB_TRANSFER_TYPE_INTERRUPT,\n    LIBUSB_TRANSFER_TYPE_BULK,\n    LIBUSB_RECIPIENT_DEVICE,\n    LIBUSB_RECIPIENT_INTERFACE,\n    LIBUSB_RECIPIENT_ENDPOINT,\n    LIBUSB_RECIPIENT_OTHER,\n    LIBUSB_REQUEST_TYPE_STANDARD,\n    LIBUSB_REQUEST_TYPE_CLASS,\n    LIBUSB_REQUEST_TYPE_VENDOR,\n    EndpointDescriptor,\n    DeviceDescriptor,\n    Capability\n} from \"usb\";\nimport { USBConfiguration } from \"./configuration\";\nimport { USBInterface } from \"./interface\";\nimport { USBAlternateInterface } from \"./alternate\";\nimport { USBEndpoint } from \"./endpoint\";\nimport { USBDevice } from \"./device\";\n\n/**\n * @hidden\n */\nconst DEFAULT_DELAY_TIMEOUT = 200;\n/**\n * @hidden\n */\nconst DEFAULT_RETRY_COUNT = 10;\n\n/**\n * @hidden\n */\nconst CONSTANTS = {\n    WEB_UUID: \"3408b638-09a9-47a0-8bfd-a0768815b665\",\n    LIBUSB_DT_BOS: 0x0f,\n    LIBUSB_DT_BOS_SIZE: 0x05,\n    LIBUSB_TRANSFER_TYPE_MASK: 0x03,\n    USB_VERSION: 0x201,\n    CAPABILITY_VERSION: 0x0100,\n    URL_REQUEST_TYPE: 0xC0,\n    URL_REQUEST_INDEX: 0x02,\n    CLEAR_FEATURE: 0x01,\n    ENDPOINT_HALT: 0x00\n};\n\n/**\n * @hidden\n */\nexport interface Adapter {\n    getConnected(handle: string): boolean;\n    getOpened(handle: string): boolean;\n\n    listUSBDevices(preFilters?: Array<USBDeviceFilter>): Promise<Array<USBDevice>>;\n    open(handle: string): Promise<void>;\n    close(handle: string): Promise<void>;\n    selectConfiguration(handle: string, id: number): Promise<void>;\n    claimInterface(handle: string, address: number): Promise<void>;\n    releaseInterface(handle: string, address: number): Promise<void>;\n    selectAlternateInterface(handle: string, interfaceNumber: number, alternateSetting: number): Promise<void>;\n    controlTransferIn(handle: string, setup: USBControlTransferParameters, length: number): Promise<USBInTransferResult>;\n    controlTransferOut(handle: string, setup: USBControlTransferParameters, data: ArrayBuffer | ArrayBufferView): Promise<USBOutTransferResult>;\n    clearHalt(handle: string, direction: USBDirection, endpointNumber: number): Promise<void>;\n    transferIn(handle: string, endpointNumber: number, length: number): Promise<USBInTransferResult>;\n    transferOut(handle: string, endpointNumber: number, data: BufferSource): Promise<USBOutTransferResult>;\n    isochronousTransferIn(_handle: string, _endpointNumber: number, _packetLengths: Array<number>): Promise<USBIsochronousInTransferResult>;\n    isochronousTransferOut(_handle: string, _endpointNumber: number, _data: BufferSource, _packetLengths: Array<number>): Promise<USBIsochronousOutTransferResult>;\n    reset(handle: string): Promise<void>;\n}\n\n/**\n * @hidden\n */\nexport class USBAdapter extends EventEmitter implements Adapter {\n\n    public static EVENT_DEVICE_CONNECT: string = \"connect\";\n    public static EVENT_DEVICE_DISCONNECT: string = \"disconnect\";\n\n    // Maintains a live list of connected Web USB devices\n    private devices: { [key: string]: { device: Device, url: string }} = {};\n\n    constructor() {\n        super();\n\n        const attachCallback = device => {\n            this.loadDevice(device, DEFAULT_RETRY_COUNT)\n            .then(loadedDevice => {\n                if (loadedDevice) {\n                    const handle = this.getDeviceHandle(loadedDevice);\n                    this.devicetoUSBDevice(handle)\n                    .then(usbDevice => {\n                        if (usbDevice) {\n                            this.emit(USBAdapter.EVENT_DEVICE_CONNECT, usbDevice);\n                        }\n                    });\n                }\n            });\n        };\n\n        const detachCallback = device => {\n            const handle = this.getDeviceHandle(device);\n\n            if (handle && this.devices[handle]) {\n                delete this.devices[handle];\n                this.emit(USBAdapter.EVENT_DEVICE_DISCONNECT, handle);\n            }\n        };\n\n        this.on(\"newListener\", event => {\n            const listenerCount = this.listenerCount(event);\n\n            if (listenerCount !== 0) {\n                return;\n            }\n\n            if (event === USBAdapter.EVENT_DEVICE_CONNECT) {\n                on(\"attach\", attachCallback);\n            } else if (event === USBAdapter.EVENT_DEVICE_DISCONNECT) {\n                on(\"detach\", detachCallback);\n            }\n        });\n\n        this.on(\"removeListener\", event => {\n            const listenerCount = this.listenerCount(event);\n\n            if (listenerCount !== 0) {\n                return;\n            }\n\n            if (event === USBAdapter.EVENT_DEVICE_CONNECT) {\n                removeListener(\"attach\", attachCallback);\n            } else if (event === USBAdapter.EVENT_DEVICE_DISCONNECT) {\n                removeListener(\"detach\", detachCallback);\n            }\n        });\n    }\n\n    private getDeviceHandle(device: Device): string {\n        if (device.busNumber === null || device.deviceAddress === null) {\n            return null;\n        }\n\n        return `${device.busNumber}.${device.deviceAddress}`;\n    }\n\n    private serialPromises<T>(task: (param: any) => Promise<T>, params: Array<any>): Promise<Array<T>> {\n        function reducer(chain, param) {\n            return chain\n            .then(results => {\n                return task.call(this, param)\n                .then(result => {\n                    if (result) {\n                        results.push(result);\n                    }\n                    return results;\n                });\n            });\n        }\n        return params.reduce(reducer.bind(this), Promise.resolve([]));\n    }\n\n    private serialDevicePromises<T>(task: (device: Device, descriptor: any) => Promise<T>, device: Device, descriptors: Array<any>): Promise<Array<T>> {\n        function reducer(chain, descriptor) {\n            return chain\n            .then(results => {\n                return task.call(this, device, descriptor)\n                .then(result => {\n                    results.push(result);\n                    return results;\n                });\n            });\n        }\n        return descriptors.reduce(reducer.bind(this), Promise.resolve([]));\n    }\n\n    private delay(timeout: number = DEFAULT_DELAY_TIMEOUT): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            setTimeout(resolve, timeout);\n        });\n    }\n\n    private retryPromise(fn: () => Promise<any>, retries: number = 0, timeout: number = DEFAULT_DELAY_TIMEOUT): Promise<void> {\n        return new Promise((resolve, reject) => {\n            fn()\n            .then(resolve)\n            .catch(error => {\n                if (retries === 0) {\n                    return reject(error);\n                }\n\n                return this.delay(timeout)\n                .then(() => this.retryPromise(fn, --retries, timeout))\n                .then(resolve)\n                .catch(retryError => reject(retryError));\n            });\n        });\n    }\n\n    private loadDevices(preFilters?: Array<USBDeviceFilter>): Promise<Array<Device>> {\n        // Reset device cache\n        this.devices = {};\n        let devices = getDeviceList();\n\n        if (preFilters) {\n            // Pre-filter devices\n            devices = this.preFilterDevices(devices, preFilters);\n        }\n\n        return this.serialPromises(this.loadDevice, devices);\n    }\n\n    private preFilterDevices(devices: Array<Device>, preFilters: Array<USBDeviceFilter>): Array<Device> {\n        // Just pre-filter on vid/pid\n        return devices.filter(device => preFilters.some(filter => {\n            // Vendor\n            if (filter.vendorId && filter.vendorId !== device.deviceDescriptor.idVendor) return false;\n\n            // Product\n            if (filter.productId && filter.productId !== device.deviceDescriptor.idProduct) return false;\n\n            // Ignore serial number for node-usb as it requires device connection\n            return true;\n        }));\n    }\n\n    private loadDevice(device: Device, retries: number = 0): Promise<Device> {\n\n        // Early guard against unsupported USB devices\n        try {\n            // tslint:disable-next-line:no-unused-expression\n            device.configDescriptor;\n            // tslint:disable-next-line:no-unused-expression\n            device.allConfigDescriptors;\n            // tslint:disable-next-line:no-unused-expression\n            device.deviceDescriptor;\n        } catch (_error) {\n            return Promise.resolve(null);\n        }\n\n        return this.getCapabilities(device, retries)\n        .then(capabilities => this.getWebCapability(capabilities))\n        .then(capability => {\n            return this.getWebUrl(device, capability)\n            .then(url => {\n                const handle = this.getDeviceHandle(device);\n                this.devices[handle] = {\n                    device: device,\n                    url: url\n                };\n                return device;\n            });\n        });\n    }\n\n    private getCapabilities(device: Device, retries: number): Promise<Array<Capability>> {\n        return new Promise((resolve, _reject) => {\n\n            this.openDevice(device, retries)\n            .then(() => {\n                device.getCapabilities((error, capabilities) => {\n                    try {\n                        // Older macs (<10.12) can error with some host devices during a close at this point\n                        device.close();\n                    // tslint:disable-next-line:no-empty\n                    } catch (_error) {}\n                    if (error) return resolve([]);\n                    resolve(capabilities);\n                });\n            })\n            .catch(_error => {\n                resolve([]);\n            });\n        });\n    }\n\n    private getWebCapability(capabilities: Array<Capability>): Capability {\n        const platformCapabilities = capabilities.filter(capability => {\n            return capability.type === 5;\n        });\n\n        const webCapability = platformCapabilities.find(capability => {\n            const uuid = this.decodeUUID(capability.data.slice(1, 17));\n            const version = capability.data.readUInt16LE(17);\n            return uuid === CONSTANTS.WEB_UUID && version === CONSTANTS.CAPABILITY_VERSION;\n        });\n\n        return webCapability;\n    }\n\n    private decodeUUID(buffer: Buffer): string {\n        const data1 = `00000000${buffer.readUInt32LE(0).toString(16)}`.slice(-8);\n        const data2 = `0000${buffer.readUInt16LE(4).toString(16)}`.slice(-4);\n        const data3 = `0000${buffer.readUInt16LE(6).toString(16)}`.slice(-4);\n\n        const data4 = [];\n        for (let i = 8; i < 10; i ++) {\n            data4.push(`00${buffer.readUInt8(i).toString(16)}`.slice(-2));\n        }\n\n        const data5 = [];\n        for (let i = 10; i < 16; i ++) {\n            data5.push(`00${buffer.readUInt8(i).toString(16)}`.slice(-2));\n        }\n\n        return `${data1}-${data2}-${data3}-${data4.join(\"\")}-${data5.join(\"\")}`;\n    }\n\n    private getWebUrl(device: Device, capability: Capability, suppressErrors: boolean = true): Promise<string> {\n        return new Promise((resolve, reject) => {\n            if (!capability || !capability.data || capability.data.byteLength < 20) return resolve(null);\n\n            const vendor = capability.data.readUInt8(19);\n            const page = capability.data.readUInt8(20);\n\n            this.openDevice(device)\n            .then(() => {\n                device.controlTransfer(CONSTANTS.URL_REQUEST_TYPE, vendor, page, CONSTANTS.URL_REQUEST_INDEX, 64, (error, buffer) => {\n                    device.close();\n\n                    if (error) {\n                        // An error may be due to the URL not existing\n                        if (suppressErrors) return resolve(null);\n                        else return reject(error);\n                    }\n\n                    // const length = buffer.readUInt8(0);\n                    // const type = buffer.readUInt8(1);\n                    let url = buffer.toString(\"utf8\", 3);\n\n                    const scheme = buffer.readUInt8(2); // 0 - http, 1 - https, 255 - in url\n                    if (scheme === 0) url = \"http://\" + url;\n                    if (scheme === 1) url = \"https://\" + url;\n\n                    resolve(url);\n                });\n            })\n            .catch(_error => {\n                resolve(\"\");\n            });\n        });\n    }\n\n    private devicetoUSBDevice(handle: string): Promise<USBDevice> {\n        return new Promise((resolve, _reject) => {\n            const device = this.devices[handle].device;\n            const url = this.devices[handle].url;\n\n            let configs: Array<ConfigDescriptor> = null;\n            let configDescriptor: ConfigDescriptor = null;\n            let deviceDescriptor: DeviceDescriptor = null;\n\n            try {\n                configDescriptor = device.configDescriptor;\n                configs = device.allConfigDescriptors;\n                deviceDescriptor = device.deviceDescriptor;\n            } catch (_error) {\n                return resolve(null);\n            }\n\n            if (!configs) return resolve(null);\n\n            return this.serialDevicePromises(this.configToUSBConfiguration, device, configs)\n            .then(configurations => {\n\n                if (!deviceDescriptor) {\n                    return resolve(new USBDevice({\n                        _handle: this.getDeviceHandle(device),\n                        url: url,\n                        configurations: configurations\n                    }));\n                }\n\n                const deviceVersion = this.decodeVersion(deviceDescriptor.bcdDevice);\n                const usbVersion = this.decodeVersion(deviceDescriptor.bcdUSB);\n                let manufacturerName = null;\n                let productName = null;\n\n                return this.getStringDescriptor(device, deviceDescriptor.iManufacturer)\n                .then(name => {\n                    manufacturerName = name;\n                    return this.getStringDescriptor(device, deviceDescriptor.iProduct);\n                })\n                .then(name => {\n                    productName = name;\n                    return this.getStringDescriptor(device, deviceDescriptor.iSerialNumber);\n                })\n                .then(serialNumber => {\n                    const props: Partial<USBDevice> = {\n                        _handle: this.getDeviceHandle(device),\n                        _maxPacketSize: deviceDescriptor.bMaxPacketSize0,\n                        url: url,\n                        deviceClass: deviceDescriptor.bDeviceClass,\n                        deviceSubclass: deviceDescriptor.bDeviceSubClass,\n                        deviceProtocol: deviceDescriptor.bDeviceProtocol,\n                        productId: deviceDescriptor.idProduct,\n                        vendorId: deviceDescriptor.idVendor,\n                        deviceVersionMajor: deviceVersion.major,\n                        deviceVersionMinor: deviceVersion.minor,\n                        deviceVersionSubminor: deviceVersion.sub,\n                        usbVersionMajor: usbVersion.major,\n                        usbVersionMinor: usbVersion.minor,\n                        usbVersionSubminor: usbVersion.sub,\n                        manufacturerName: manufacturerName,\n                        productName: productName,\n                        serialNumber: serialNumber,\n                        configurations: configurations,\n                        _currentConfiguration: configDescriptor.bConfigurationValue\n                    };\n                    return resolve(new USBDevice(props));\n                });\n            }).catch(_error => {\n                resolve(null);\n            });\n        });\n    }\n\n    private decodeVersion(version: number): { [key: string]: number } {\n        const hex = `0000${version.toString(16)}`.slice(-4);\n        return {\n            major: parseInt(hex.substr(0, 2), null),\n            minor: parseInt(hex.substr(2, 1), null),\n            sub: parseInt(hex.substr(3, 1), null),\n        };\n    }\n\n    private getStringDescriptor(device: Device, index: number): Promise<string> {\n        return new Promise(resolve => {\n            this.openDevice(device)\n            .then(() => {\n                device.getStringDescriptor(index, (error, buffer) => {\n                    device.close();\n                    resolve(error ? \"\" : buffer.toString());\n                });\n            })\n            .catch(_error => {\n                resolve(\"\");\n            });\n        });\n    }\n\n    private bufferToDataView(buffer: Buffer): DataView {\n        const arrayBuffer = new Uint8Array(buffer).buffer;\n        return new DataView(arrayBuffer);\n    }\n\n    private bufferSourceToBuffer(bufferSource: ArrayBuffer | ArrayBufferView): Buffer {\n        const arrayBuffer = ArrayBuffer.isView(bufferSource)\n            ? bufferSource.buffer.slice(bufferSource.byteOffset, bufferSource.byteOffset + bufferSource.byteLength)\n            : bufferSource;\n\n        return Buffer.from(arrayBuffer);\n    }\n\n    private getEndpoint(device: Device, direction: USBDirection, endpointNumber: number): Endpoint {\n        let endpoint: Endpoint = null;\n        const address = endpointNumber | (direction === \"in\" ? LIBUSB_ENDPOINT_IN : LIBUSB_ENDPOINT_OUT);\n\n        device.interfaces.some(iface => {\n            const epoint = iface.endpoint(address);\n\n            if (epoint) {\n                endpoint = epoint;\n                return true;\n            }\n            return false;\n        });\n\n        return endpoint;\n    }\n\n    private getInEndpoint(device: Device, endpointNumber: number): InEndpoint {\n        const endpoint = this.getEndpoint(device, \"in\", endpointNumber);\n        if (endpoint && endpoint.direction === \"in\") return (endpoint as InEndpoint);\n    }\n\n    private getOutEndpoint(device: Device, endpointNumber: number): OutEndpoint {\n        const endpoint = this.getEndpoint(device, \"out\", endpointNumber);\n        if (endpoint && endpoint.direction === \"out\") return (endpoint as OutEndpoint);\n    }\n\n    private endpointToUSBEndpoint(descriptor: EndpointDescriptor): USBEndpoint {\n        const direction = descriptor.bEndpointAddress & LIBUSB_ENDPOINT_IN ? \"in\" : \"out\";\n        return new USBEndpoint({\n            endpointNumber: descriptor.bEndpointAddress ^ (direction === \"in\" ? LIBUSB_ENDPOINT_IN : LIBUSB_ENDPOINT_OUT),\n            direction: direction,\n            type: (descriptor.bmAttributes & CONSTANTS.LIBUSB_TRANSFER_TYPE_MASK) === LIBUSB_TRANSFER_TYPE_BULK ? \"bulk\"\n                : (descriptor.bmAttributes & CONSTANTS.LIBUSB_TRANSFER_TYPE_MASK) === LIBUSB_TRANSFER_TYPE_INTERRUPT ? \"interrupt\"\n                : \"isochronous\",\n            packetSize: descriptor.wMaxPacketSize\n        });\n    }\n\n    private interfaceToUSBAlternateInterface(device: Device, descriptor: InterfaceDescriptor): Promise<USBAlternateInterface> {\n        return this.getStringDescriptor(device, descriptor.iInterface)\n        .then(name => {\n            return new USBAlternateInterface({\n                alternateSetting: descriptor.bAlternateSetting,\n                interfaceClass: descriptor.bInterfaceClass,\n                interfaceSubclass: descriptor.bInterfaceSubClass,\n                interfaceProtocol: descriptor.bInterfaceProtocol,\n                interfaceName: name,\n                endpoints: descriptor.endpoints.map(this.endpointToUSBEndpoint)\n            });\n        });\n    }\n\n    private interfacesToUSBInterface(device: Device, descriptors: Array<InterfaceDescriptor>): Promise<USBInterface> {\n        return this.serialDevicePromises(this.interfaceToUSBAlternateInterface, device, descriptors)\n        .then(alternates => {\n            return new USBInterface({\n                _handle: this.getDeviceHandle(device),\n                interfaceNumber: descriptors[0].bInterfaceNumber,\n                alternates: alternates\n            });\n        });\n    }\n\n    private configToUSBConfiguration(device: Device, descriptor: ConfigDescriptor): Promise<USBConfiguration> {\n        return this.getStringDescriptor(device, descriptor.iConfiguration)\n        .then(name => {\n            const allInterfaces = descriptor.interfaces || [];\n\n            return this.serialDevicePromises(this.interfacesToUSBInterface, device, allInterfaces)\n            .then(interfaces => {\n                return new USBConfiguration({\n                    configurationValue: descriptor.bConfigurationValue,\n                    configurationName: name,\n                    interfaces: interfaces\n                });\n            });\n        });\n    }\n\n    private getDevice(handle: string): Device {\n        if (!this.devices[handle]) return null;\n        return this.devices[handle].device;\n    }\n\n    private controlTransferParamsToType(setup: USBControlTransferParameters, direction: number): number {\n        const recipient = setup.recipient === \"device\" ? LIBUSB_RECIPIENT_DEVICE\n                        : setup.recipient === \"interface\" ? LIBUSB_RECIPIENT_INTERFACE\n                        : setup.recipient === \"endpoint\" ? LIBUSB_RECIPIENT_ENDPOINT\n                        : LIBUSB_RECIPIENT_OTHER;\n\n        const requestType = setup.requestType === \"standard\" ? LIBUSB_REQUEST_TYPE_STANDARD\n                          : setup.requestType === \"class\" ? LIBUSB_REQUEST_TYPE_CLASS\n                          : LIBUSB_REQUEST_TYPE_VENDOR;\n\n        return recipient | requestType | direction;\n    }\n\n    private openDevice(device: Device, retries: number = 0): Promise<void> {\n        return this.retryPromise(() => {\n            return new Promise<void>((resolve, reject) => {\n                try {\n                    device.open();\n                } catch (error) {\n                    return reject(error);\n                }\n                resolve();\n            });\n        }, retries);\n    }\n\n    public getConnected(handle: string): boolean {\n        return this.getDevice(handle) !== null;\n    }\n\n    public getOpened(handle: string): boolean {\n        const device = this.getDevice(handle);\n        if (!device) return false;\n        return (device.interfaces !== null);\n    }\n\n    public listUSBDevices(preFilters?: Array<USBDeviceFilter>): Promise<Array<USBDevice>> {\n        return this.loadDevices(preFilters)\n        .then(() => {\n            return this.serialPromises(this.devicetoUSBDevice, Object.keys(this.devices));\n        });\n    }\n\n    public open(handle: string): Promise<void> {\n        const device = this.getDevice(handle);\n        return this.openDevice(device);\n    }\n\n    public close(handle: string): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            const device = this.getDevice(handle);\n            device.close();\n            resolve();\n        });\n    }\n\n    public selectConfiguration(handle: string, id: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n\n            device.setConfiguration(id, error => {\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n\n    public claimInterface(handle: string, address: number): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            const device = this.getDevice(handle);\n\n            device.interface(address).claim();\n            resolve();\n        });\n    }\n\n    public releaseInterface(handle: string, address: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n\n            device.interface(address).release(true, error => {\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n\n    public selectAlternateInterface(handle: string, interfaceNumber: number, alternateSetting: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            const iface = device.interface(interfaceNumber);\n\n            iface.setAltSetting(alternateSetting, error => {\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n\n    public controlTransferIn(handle: string, setup: USBControlTransferParameters, length: number): Promise<USBInTransferResult> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            const type = this.controlTransferParamsToType(setup, LIBUSB_ENDPOINT_IN);\n\n            device.controlTransfer(type, setup.request, setup.value, setup.index, length, (error, buffer) => {\n                if (error) {\n                    if (error.errno === LIBUSB_TRANSFER_STALL) {\n                        return resolve({\n                            status: \"stall\"\n                        });\n                    } else if (error.errno === LIBUSB_TRANSFER_OVERFLOW) {\n                        return resolve({\n                            status: \"babble\"\n                        });\n                    }\n\n                    return reject(error);\n                }\n\n                resolve({\n                    data: this.bufferToDataView(buffer),\n                    status: \"ok\"\n                });\n            });\n        });\n    }\n\n    public controlTransferOut(handle: string, setup: USBControlTransferParameters, data?: ArrayBuffer | ArrayBufferView): Promise<USBOutTransferResult> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            const type = this.controlTransferParamsToType(setup, LIBUSB_ENDPOINT_OUT);\n            const buffer = data ? this.bufferSourceToBuffer(data) : new Buffer(0);\n\n            device.controlTransfer(type, setup.request, setup.value, setup.index, buffer, error => {\n                if (error) {\n                    if (error.errno === LIBUSB_TRANSFER_STALL) {\n                        return resolve({\n                            bytesWritten: 0,\n                            status: \"stall\"\n                        });\n                    }\n\n                    return reject(error);\n                }\n\n                resolve({\n                    bytesWritten: buffer.byteLength, // hack, should be bytes actually written\n                    status: \"ok\" // hack\n                });\n            });\n        });\n    }\n\n    public clearHalt(handle: string, direction: USBDirection, endpointNumber: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            const wIndex = endpointNumber | (direction === \"in\" ? LIBUSB_ENDPOINT_IN : LIBUSB_ENDPOINT_OUT);\n            device.controlTransfer(LIBUSB_RECIPIENT_ENDPOINT, CONSTANTS.CLEAR_FEATURE, CONSTANTS.ENDPOINT_HALT, wIndex, 0, error => {\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n\n    public transferIn(handle: string, endpointNumber: number, length: number): Promise<USBInTransferResult> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            const endpoint = this.getInEndpoint(device, endpointNumber);\n\n            endpoint.transfer(length, (error, data) => {\n                if (error) {\n                    if (error.errno === LIBUSB_TRANSFER_STALL) {\n                        return resolve({\n                            status: \"stall\"\n                        });\n                    } else if (error.errno === LIBUSB_TRANSFER_OVERFLOW) {\n                        return resolve({\n                            status: \"babble\"\n                        });\n                    }\n\n                    return reject(error);\n                }\n\n                resolve({\n                    data: this.bufferToDataView(data),\n                    status: \"ok\"\n                });\n            });\n        });\n    }\n\n    public transferOut(handle: string, endpointNumber: number, data: BufferSource): Promise<USBOutTransferResult> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            const endpoint = this.getOutEndpoint(device, endpointNumber);\n            const buffer = this.bufferSourceToBuffer(data);\n\n            endpoint.transfer(buffer, error => {\n                if (error) {\n                    if (error.errno === LIBUSB_TRANSFER_STALL) {\n                        return resolve({\n                            bytesWritten: 0,\n                            status: \"stall\"\n                        });\n                    }\n\n                    return reject(error);\n                }\n\n                resolve({\n                    bytesWritten: buffer.byteLength, // hack, should be bytes actually written\n                    status: \"ok\" // hack\n                });\n            });\n        });\n    }\n\n    public isochronousTransferIn(_handle: string, _endpointNumber: number, _packetLengths: Array<number>): Promise<USBIsochronousInTransferResult> {\n        return new Promise((_resolve, reject) => {\n            reject(\"isochronousTransferIn error: method not implemented\");\n        });\n    }\n\n    public isochronousTransferOut(_handle: string, _endpointNumber: number, _data: BufferSource, _packetLengths: Array<number>): Promise<USBIsochronousOutTransferResult> {\n        return new Promise((_resolve, reject) => {\n            reject(\"isochronousTransferOut error: method not implemented\");\n        });\n    }\n\n    public reset(handle: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const device = this.getDevice(handle);\n            device.reset(error => {\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n}\n\n/**\n * @hidden\n */\nexport const adapter = new USBAdapter();\n","/*\n* Node WebUSB\n* Copyright (c) 2019 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n// tslint:disable:max-classes-per-file\n\n/**\n * @hidden\n */\nexport class DOMEvent implements Event {\n\n    /**\n     * Type of the event\n     */\n    public type: string;\n\n    /**\n     * @hidden\n     */\n    public target: EventTarget;\n\n    /**\n     * @hidden\n     */\n    public currentTarget: EventTarget;\n\n    /**\n     * @hidden\n     */\n    public srcElement: EventTarget;\n\n    /**\n     * @hidden\n     */\n    public timeStamp: number;\n\n    /**\n     * @hidden\n     */\n    public bubbles = false;\n\n    /**\n     * @hidden\n     */\n    public cancelable = false;\n\n    /**\n     * @hidden\n     */\n    public cancelBubble = false;\n\n    /**\n     * @hidden\n     */\n    public composed = false;\n\n    /**\n     * @hidden\n     */\n    public defaultPrevented = false;\n\n    /**\n     * @hidden\n     */\n    public eventPhase = 0;\n\n    /**\n     * @hidden\n     */\n    public isTrusted = true;\n\n    /**\n     * @hidden\n     */\n    public returnValue = true;\n\n    /**\n     * @hidden\n     */\n    public AT_TARGET: number;\n\n    /**\n     * @hidden\n     */\n    public BUBBLING_PHASE: number;\n\n    /**\n     * @hidden\n     */\n    public CAPTURING_PHASE: number;\n\n    /**\n     * @hidden\n     */\n    public NONE: number;\n\n    /**\n     * @hidden\n     */\n    public composedPath(): Array<EventTarget> {\n        return [];\n    }\n\n    /**\n     * @hidden\n     */\n    public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n        this.type = type;\n        this.bubbles = bubbles;\n        this.cancelable = cancelable;\n    }\n\n    /**\n     * @hidden\n     */\n    public preventDefault() {\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * @hidden\n     */\n    public stopImmediatePropagation() {\n        return;\n    }\n\n    /**\n     * @hidden\n     */\n    public stopPropagation() {\n        return;\n    }\n}\n\n/**\n * @hidden\n */\nexport class W3CUSBConnectionEvent extends DOMEvent implements USBConnectionEvent {\n\n    /**\n     * Device connected or disconnected\n     */\n    public readonly device: USBDevice;\n\n    /**\n     * Type of the event\n     */\n    public readonly type: \"connect\" | \"disconnect\";\n\n    /**\n     * @hidden\n     */\n    constructor(target: EventTarget, type: \"connect\" | \"disconnect\", eventInitDict: USBConnectionEventInit) {\n        super();\n        this.initEvent(type, eventInitDict.bubbles, eventInitDict.cancelable);\n        this.target = target;\n        this.device = eventInitDict.device;\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventDispatcher, TypedDispatcher } from \"./dispatcher\";\nimport { USBAdapter, adapter } from \"./adapter\";\nimport { W3CUSBConnectionEvent } from \"./events\";\nimport { W3CUSB } from \"./interfaces\";\nimport { USBDevice as Device } from \"./device\";\n\n/**\n * USB Options\n */\nexport interface USBOptions {\n    /**\n     * A `device found` callback function to allow the user to select a device\n     */\n    devicesFound?: (devices: Array<USBDevice>) => Promise<USBDevice | void>;\n}\n\n/**\n * @hidden\n */\nexport interface USBEvents {\n    /**\n     * USBDevice connected event\n     */\n    connect: USBConnectionEvent;\n    /**\n     * USBDevice disconnected event\n     */\n    disconnect: USBConnectionEvent;\n}\n\n/**\n * USB class\n */\nexport class USB extends (EventDispatcher as new() => TypedDispatcher<USBEvents>) implements W3CUSB {\n\n    private allowedDevices: Array<Device> = [];\n    private devicesFound: (devices: Array<USBDevice>) => Promise<USBDevice | void>;\n\n    private _onconnect: (ev: USBConnectionEvent) => void;\n    public set onconnect(fn: (ev: USBConnectionEvent) => void) {\n        if (this._onconnect) {\n            this.removeEventListener(\"connect\", this._onconnect);\n        }\n        this._onconnect = fn;\n        this.addEventListener(\"connect\", this._onconnect);\n    }\n\n    private _ondisconnect: (ev: USBConnectionEvent) => void;\n    public set ondisconnect(fn: (ev: USBConnectionEvent) => void) {\n        if (this._ondisconnect) {\n            this.removeEventListener(\"disconnect\", this._ondisconnect);\n        }\n        this._ondisconnect = fn;\n        this.addEventListener(\"disconnect\", this._ondisconnect);\n    }\n\n    /**\n     * USB constructor\n     * @param options USB initialisation options\n     */\n    constructor(options?: USBOptions) {\n        super();\n\n        options = options || {};\n        this.devicesFound = options.devicesFound;\n\n        const deviceConnectCallback = device => {\n            // When connected, emit an event if it was a known allowed device\n            if (this.replaceAllowedDevice(device)) {\n                const event = new W3CUSBConnectionEvent(this as EventTarget, \"connect\", { device }) as USBConnectionEvent;\n                this.dispatchEvent(event);\n\n                if (this.onconnect) {\n                    this.onconnect(event);\n                }\n            }\n        };\n\n        const deviceDisconnectCallback = handle => {\n            // When disconnected, emit an event if the device was a known allowed device\n            const device = this.allowedDevices.find(allowedDevices => allowedDevices._handle === handle);\n\n            if (device) {\n                const event = new W3CUSBConnectionEvent(this as EventTarget, \"disconnect\", { device }) as USBConnectionEvent;\n                this.dispatchEvent(event);\n\n                if (this.ondisconnect) {\n                    this.ondisconnect(event);\n                }\n            }\n        };\n\n        this.on(\"newListener\", event => {\n            const listenerCount = this.listenerCount(event);\n\n            if (listenerCount !== 0) {\n                return;\n            }\n\n            if (event === \"connect\") {\n                adapter.addListener(USBAdapter.EVENT_DEVICE_CONNECT, deviceConnectCallback);\n            } else if (event === \"disconnect\") {\n                adapter.addListener(USBAdapter.EVENT_DEVICE_DISCONNECT, deviceDisconnectCallback);\n            }\n        });\n\n        this.on(\"removeListener\", event => {\n            const listenerCount = this.listenerCount(event);\n\n            if (listenerCount !== 0) {\n                return;\n            }\n\n            if (event === \"connect\") {\n                adapter.removeListener(USBAdapter.EVENT_DEVICE_CONNECT, deviceConnectCallback);\n            } else if (event === \"disconnect\") {\n                adapter.removeListener(USBAdapter.EVENT_DEVICE_DISCONNECT, deviceDisconnectCallback);\n            }\n        });\n    }\n\n    private replaceAllowedDevice(device: Device): boolean {\n        for (const i in this.allowedDevices) {\n            if (this.isSameDevice(device, this.allowedDevices[i])) {\n                this.allowedDevices[i] = device;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private isSameDevice(device1: USBDevice, device2: USBDevice): boolean {\n        return (device1.productId === device2.productId\n             && device1.vendorId === device2.vendorId\n             && device1.serialNumber === device2.serialNumber);\n    }\n\n    private filterDevice(options: USBDeviceRequestOptions, device: USBDevice): boolean {\n        return options.filters.some(filter => {\n            // Vendor\n            if (filter.vendorId && filter.vendorId !== device.vendorId) return false;\n\n            // Product\n            if (filter.productId && filter.productId !== device.productId) return false;\n\n            // Class\n            if (filter.classCode) {\n\n                // Interface Descriptors\n                const match = device.configuration.interfaces.some(iface => {\n                    // Class\n                    if (filter.classCode && filter.classCode !== iface.alternate.interfaceClass) return false;\n\n                    // Subclass\n                    if (filter.subclassCode && filter.subclassCode !== iface.alternate.interfaceSubclass) return false;\n\n                    // Protocol\n                    if (filter.protocolCode && filter.protocolCode !== iface.alternate.interfaceProtocol) return false;\n\n                    return true;\n                });\n\n                if (match) return true;\n            }\n\n            // Class\n            if (filter.classCode && filter.classCode !== device.deviceClass) return false;\n\n            // Subclass\n            if (filter.subclassCode && filter.subclassCode !== device.deviceSubclass) return false;\n\n            // Protocol\n            if (filter.protocolCode && filter.protocolCode !== device.deviceProtocol) return false;\n\n            // Serial\n            if (filter.serialNumber && filter.serialNumber !== device.serialNumber) return false;\n\n            return true;\n        });\n    }\n\n    /**\n     * Gets all allowed Web USB devices which are connected\n     * @returns Promise containing an array of devices\n     */\n    public getDevices(): Promise<Array<USBDevice>> {\n        // Create pre-filters\n        const preFilters = this.allowedDevices.map(device => ({\n            vendorId: device.vendorId || undefined,\n            productId: device.productId || undefined,\n            classCode: device.deviceClass || undefined,\n            subclassCode: device.deviceSubclass || undefined,\n            protocolCode: device.deviceProtocol || undefined,\n            serialNumber: device.serialNumber || undefined\n        }));\n\n        // Refresh devices and filter for allowed ones\n        return adapter.listUSBDevices(preFilters)\n        .then(devices => {\n            const allowed = devices.filter(device => {\n                if (!device.connected) {\n                    return false;\n                }\n\n                for (const i in this.allowedDevices) {\n                    if (this.isSameDevice(device, this.allowedDevices[i])) {\n                        return true;\n                    }\n                }\n\n                return false;\n            });\n\n            return allowed;\n        });\n    }\n\n    /**\n     * Requests a single Web USB device\n     * @param options The options to use when scanning\n     * @returns Promise containing the selected device\n     */\n    public requestDevice(options: USBDeviceRequestOptions): Promise<USBDevice> {\n        return new Promise((resolve, reject) => {\n            // Must have options\n            if (!options) {\n                return reject(new TypeError(\"requestDevice error: 1 argument required, but only 0 present\"));\n            }\n\n            // Options must be an object\n            if (options.constructor !== {}.constructor) {\n                return reject(new TypeError(\"requestDevice error: parameter 1 (options) is not an object\"));\n            }\n\n            // Must have a filter\n            if (!options.filters) {\n                return reject(new TypeError(\"requestDevice error: required member filters is undefined\"));\n            }\n\n            // Filter must be an array\n            if (options.filters.constructor !== [].constructor) {\n                return reject(new TypeError(\"requestDevice error: the provided value cannot be converted to a sequence\"));\n            }\n\n            // Check filters\n            const check = options.filters.every(filter => {\n\n                // Protocol & Subclass\n                if (filter.protocolCode && !filter.subclassCode) {\n                    reject(new TypeError(\"requestDevice error: subclass code is required\"));\n                    return false;\n                }\n\n                // Subclass & Class\n                if (filter.subclassCode && !filter.classCode) {\n                    reject(new TypeError(\"requestDevice error: class code is required\"));\n                    return false;\n                }\n\n                return true;\n            });\n\n            if (!check) return;\n\n            return adapter.listUSBDevices(options.filters)\n            .then(devices => {\n                devices = devices.filter(device => this.filterDevice(options, device));\n\n                if (devices.length === 0) {\n                    return reject(new Error(\"requestDevice error: no devices found\"));\n                }\n\n                function selectFn(device: USBDevice) {\n                    if (!this.replaceAllowedDevice(device)) this.allowedDevices.push(device);\n                    resolve(device);\n                }\n\n                // If no devicesFound function, select the first device found\n                if (!this.devicesFound) return selectFn.call(this, devices[0]);\n\n                return this.devicesFound(devices)\n                .then(device => {\n                    if (!device) {\n                        reject(new Error(\"selected device not found\"));\n                    }\n\n                    return selectFn.call(this, device);\n                });\n            }).catch(error => {\n                reject(new Error(`requestDevice error: ${error}`));\n            });\n        });\n    }\n}\n","/*\n* Node WebUSB\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { USB, USBOptions } from \"./usb\";\n\n/**\n * Default usb instance synonymous with `navigator.usb`\n */\nexport const usb = new USB();\n\n/**\n * USB class for creating new instances\n */\nexport { USB, USBOptions };\n\n/**\n * Adapter\n */\nexport {\n    adapter,\n    USBAdapter\n} from \"./adapter\";\n"],"names":["EventHandlers","EventEmitter","init","call","this","$getMaxListeners","that","undefined","_maxListeners","defaultMaxListeners","emitNone","handler","isFn","self","len","length","listeners","arrayClone","i","emitOne","arg1","emitTwo","arg2","emitThree","arg3","emitMany","args","apply","_addListener","target","type","listener","prepend","m","events","existing","e","TypeError","_events","newListener","emit","_eventsCount","unshift","push","warned","w","Error","name","emitter","count","console","warn","log","_onceWrap","fired","g","removeListener","arguments","listenerCount","evlistener","arr","copy","Array","prototype","Object","create","usingDomains","domain","active","Domain","getPrototypeOf","setMaxListeners","n","isNaN","getMaxListeners","er","doError","error","err","context","domainEmitter","domainThrown","addListener","on","prependListener","once","prependOnceListener","list","position","originalListener","index","k","pop","spliceOne","removeAllListeners","key","keys","ret","unwrapListeners","eventNames","Reflect","ownKeys","EventDispatcher","[object Object]","handleEvent","isEventListenerObject","super","callback","event","USBConfiguration","configurationValue","configurationName","interfaces","USBInterface","interfaceNumber","alternates","_handle","claimed","_claimed","alternate","find","alternateSetting","_currentAlternate","adapter","selectAlternateInterface","then","claimInterface","releaseInterface","USBAlternateInterface","interfaceClass","interfaceSubclass","interfaceProtocol","interfaceName","endpoints","USBEndpoint","endpointNumber","direction","packetSize","USBDevice","usbVersionMajor","usbVersionMinor","usbVersionSubminor","deviceClass","deviceSubclass","deviceProtocol","vendorId","productId","deviceVersionMajor","deviceVersionMinor","deviceVersionSubminor","manufacturerName","productName","serialNumber","_configurations","configurations","url","_maxPacketSize","_currentConfiguration","configuration","connected","getConnected","opened","getOpened","endpoint","iface","some","usbInterface","usbEndpoint","setup","recipient","LIBUSB_ENDPOINT_IN","result","getEndpoint","Promise","resolve","reject","open","catch","releaseInterfacePromises","map","all","_error","close","selectConfiguration","forEach","reset","setupError","setupInvalid","controlTransferIn","data","controlTransferOut","clearHalt","transferIn","transferOut","packetLengths","isochronousTransferIn","isochronousTransferOut","DEFAULT_DELAY_TIMEOUT","DEFAULT_RETRY_COUNT","CONSTANTS","WEB_UUID","LIBUSB_DT_BOS","LIBUSB_DT_BOS_SIZE","LIBUSB_TRANSFER_TYPE_MASK","USB_VERSION","CAPABILITY_VERSION","URL_REQUEST_TYPE","URL_REQUEST_INDEX","CLEAR_FEATURE","ENDPOINT_HALT","USBAdapter","attachCallback","device","loadDevice","loadedDevice","handle","getDeviceHandle","devicetoUSBDevice","usbDevice","EVENT_DEVICE_CONNECT","detachCallback","devices","EVENT_DEVICE_DISCONNECT","busNumber","deviceAddress","task","params","reduce","chain","param","results","bind","descriptors","descriptor","timeout","_reject","setTimeout","fn","retries","delay","retryPromise","retryError","preFilters","getDeviceList","preFilterDevices","serialPromises","filter","deviceDescriptor","idVendor","idProduct","configDescriptor","allConfigDescriptors","getCapabilities","capabilities","getWebCapability","capability","getWebUrl","openDevice","uuid","decodeUUID","slice","version","readUInt16LE","buffer","data1","readUInt32LE","toString","data2","data3","data4","readUInt8","data5","join","suppressErrors","byteLength","vendor","page","controlTransfer","scheme","configs","serialDevicePromises","configToUSBConfiguration","deviceVersion","decodeVersion","bcdDevice","usbVersion","bcdUSB","getStringDescriptor","iManufacturer","iProduct","iSerialNumber","props","bMaxPacketSize0","bDeviceClass","bDeviceSubClass","bDeviceProtocol","major","minor","sub","bConfigurationValue","hex","parseInt","substr","arrayBuffer","Uint8Array","DataView","bufferSource","ArrayBuffer","isView","byteOffset","Buffer","from","address","LIBUSB_ENDPOINT_OUT","epoint","bEndpointAddress","bmAttributes","LIBUSB_TRANSFER_TYPE_BULK","LIBUSB_TRANSFER_TYPE_INTERRUPT","wMaxPacketSize","iInterface","bAlternateSetting","bInterfaceClass","bInterfaceSubClass","bInterfaceProtocol","endpointToUSBEndpoint","interfaceToUSBAlternateInterface","bInterfaceNumber","iConfiguration","allInterfaces","interfacesToUSBInterface","LIBUSB_RECIPIENT_DEVICE","LIBUSB_RECIPIENT_INTERFACE","LIBUSB_RECIPIENT_ENDPOINT","LIBUSB_RECIPIENT_OTHER","requestType","LIBUSB_REQUEST_TYPE_STANDARD","LIBUSB_REQUEST_TYPE_CLASS","LIBUSB_REQUEST_TYPE_VENDOR","getDevice","loadDevices","id","setConfiguration","interface","claim","release","setAltSetting","controlTransferParamsToType","request","value","errno","LIBUSB_TRANSFER_STALL","status","LIBUSB_TRANSFER_OVERFLOW","bufferToDataView","bufferSourceToBuffer","bytesWritten","wIndex","getInEndpoint","transfer","getOutEndpoint","_endpointNumber","_packetLengths","_resolve","_data","DOMEvent","bubbles","cancelable","defaultPrevented","W3CUSBConnectionEvent","eventInitDict","initEvent","USB","options","devicesFound","deviceConnectCallback","replaceAllowedDevice","dispatchEvent","onconnect","deviceDisconnectCallback","allowedDevices","ondisconnect","_onconnect","removeEventListener","addEventListener","_ondisconnect","isSameDevice","device1","device2","filters","classCode","subclassCode","protocolCode","listUSBDevices","constructor","every","filterDevice","selectFn","usb"],"mappings":"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"}